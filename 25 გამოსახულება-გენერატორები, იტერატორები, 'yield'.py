
'გამოსახულება გენერატორები'
'იტერატორები'
'yield'
a = [i for i in range(1, 6)]
print(a)
# გამოსახულება
b = (i for i in range(1, 6))
# კორტეჟის არის ()
# მაგრამ ამ შემთხვევაში ის არის გენერატორი გამოსახულება
# b ში ჩაჯდება გენერატორი ობიექტი
print(b)
'----------------------------------------------------------'
' გენერატორი- იტერატორი, ელემენტების იტერირება შესაძლოა მხოლოდ ერთხელ!'
'იტერატორი- ობიექტი,გააჩნია next() ფუნქცია.'
'ობიექტს "ახსოვს" თუ რომელი ელემენტი იქნება აღებული შემდეგ წრეზე'
'იტერირებადი ობიექტი- ობიექტი იძლევა საშუალებას მიმდევრობით დავუაროთ მის ელემენტებს'
'იტერირებადი ობიექტი სეიძლება გარდაიქმნას იტერატორად' ' სია -> იტერატორი'
'----------------------------------------------------------------'
'ნექსთით დავლა შესაძლებელია მხოლოდ ერთხელ'
b = (i for i in range(1, 6))
# ნექსთ ფუნქცია
print(next(b))  # პირველი ელემენტი გამოიძახა
print(next(b))  # შემდეგი ელემენტი და ყოველ ჯერზე 6 მდე
print(next(b))
'----------------------------'
'გარდაქმენი გამისახულება ლისტ იტერატორად'
print(a)
d = iter(a)
print(d)
# ნექსთ ფუნქცია შესაძლოა
print(next(d))
# გენერატორი ობიექტი იქსი
x = (i for i in range(1, 4))
print(x)
sum(x)  # ჯამი შეიძლება
sum(x)  # მხოლოდ ერთხელ იქნება შესაძლებელი
print("0 iqneba")
'სულ ნექსთით რომ არ ვიძახო'
c = (i for i in range(10))
# ციკლის მერე გამოიტანს ყველა ობიექტს
for i in c:
    print(i)
'-----------'
for i in c:
    print(i)  # მეორედ არაკეთებს
'მეხსიერების გადატვირთვის პრობლემა'
# დიდის დაგენერირება
a = list(range(100))
# აქ უკვე პრობლემა აღარაა
d = (i for i in range(5))
'გენერატორი არ იმახსოვრებს'
'იმახსოვრებს მიმდინარე მომენტს და იყენებს შემდეგი ობიექტის გამოსატანად'
print(next(d))
for i in d:
    print(i)
'--------------------------------------'
'აქ მინუსები'
# სიგრძეს ვერ ზომავს
'len(d)'
# ინდექსირება არ არის
'd(999)'
'-----------------------------------------'
'დაგენერირება არის ბევრად სწრაფი'
# a გენერატორი ობიექტი შევქმენი
a = (i for i in range(1, 10))
# სიაში გადავიტანე და შევინახე
b = list(a)
'-----------------------------------------------'


def fun():
    return[1, 3, 5]


print(fun())
'------------------------------------------------'
'გენერატორი ფუნქცია'


def funcgen():  # შემოვიდ აქ
    for i in [1, 3, 5]:  # დაიწყო დაგენერირება
        yield(i)  # ერთიანზე მოვიდა და დააბრუნა ერთიანი


# პირველი ორპერატორი დაიარა და გაყინა'
# ვიძახებ ფუნქციას
z = funcgen()
print(next(z))
print(next(z))
'yield გაყინავს დაბეჭდავს გადავა გაყინავს დავბეჭდავს'
'---------------------------------------------------------'


def funcgen():  # პირველი წრე შემოვიდა
    t = 9
    # პირვე წრე ციკლში შემოვიდა და 1, გაჩერდა
    for i in [1, 2, 3]:  # მესამეზე შემოვა 2,
        yield(i)  # [ STOP PLACE]
        # პირველი წრე დააბრუნა 1, და დაბეჭდა
        # მესამეზე დააბრუნა 2, და დაბეჭდა
        # მეორე წრეს აქედან დაიწყებს
        print(t)  # მეორე წრეზე დაბეჭდავს 9 იანს
        # პირველი წრე არ ჩავიდა
        t = t*10  # მეორე წრეზე  დაითვლის და არ გამოიტანს


# პირველი წრე გამოიძახა
z = funcgen()
print(next(z))  # პირველი წრე
print(next(z))  # ''მეორე წრე'' მესამე შემოვლა
'---------------------------------------------------------'
'ფაქტორიალის გამოთვლა'
#  ენ არგუმენტი


def fact(n):  # შემოდი n რიცხვო
    f = 1
    a = []  # ჩაჯდება რიცვი 5 5 ჯერ
    # წინა ყველა რიცხვის ნამრავლი
    for i in range(1, n+1):
        f *= i  # ელემენტს ამრავლებს 1 ზე
        a.append(f)  # სიაში ჩავაგდოთ მიმდინარე f ის მნიშვნელობა
    return a  # გამოიტანს a ს


# გამოიძახე fact () და გაუგზავნე 5
print(fact(5))  # 5 ის ფაქტორიალი
'--------------------------------------------'
'გენერატორი ფაქტორიალის'


def factgen(n):
    f = 1
    # ყოველ ჯერზე იტერატორი შემოდის
    for i in range(1, n+1):
        f *= i  # დაითვლის მიმდინარე ფაქტორიალს
        yield f  # მიმდინარე f დამიბრუნე


        # იმახსოვრებს სად გაჩერდა
z = factgen(5)
for i in factgen(5):
    print(i, end=" ")
'-----------------------------------------------'
